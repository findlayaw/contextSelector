Enhancing Large Language Model Capabilities for Code Analysis Through Graph Databases
1. Introduction: Enhancing LLM-Based Code Analysis with Graph Databases
The landscape of software development is increasingly influenced by the capabilities of Large Language Models (LLMs), which demonstrate remarkable potential in various tasks, including code editing, understanding, and generation.1 A key challenge in effectively leveraging these models for complex domains like software engineering lies in providing them with relevant and structured context. Traditional methods often involve passing raw code or textual descriptions, which may not fully capture the intricate relationships inherent in a codebase. A novel approach gaining traction involves representing codebases as graph databases, where the syntax and structure of the code are stored as interconnected nodes and edges. This representation allows for sophisticated querying to extract precise contextual information that can then be provided to an LLM [User Query]. The increasing interest in LLMs for software engineering underscores the need for methods that can effectively supply these models with the necessary context to perform tasks accurately and efficiently. Given the interconnected nature of software components, a graph-based representation offers a potentially more intuitive and effective way to capture these relationships compared to unstructured text. This report aims to investigate the effectiveness of integrating graph databases and knowledge graphs with LLMs to enhance code understanding and manipulation, drawing upon available research and practical examples.
2. Representing Code as Knowledge: The Foundation of Code Graphs
Graph databases offer a powerful paradigm for representing the structure and semantics of code.4 In this model, various elements within a codebase, such as files, functions, classes, variables, and modules, are represented as individual nodes in the graph.4 The relationships between these code elements are then depicted as edges connecting the corresponding nodes. Common relationships include function calls, dependencies between modules, class inheritance, the usage of variables within functions, and the containment of code elements within files.4 For instance, a function that calls another function would be represented by an edge between their respective nodes, illustrating the flow of execution.6 Similarly, the use of a variable within a function would be shown by a connection between the function node and the variable node.6 This method of organizing code information leads to the creation of a Codebase Knowledge Graph (CKG), which provides a structured and interconnected view of the software.4 CKGs are essentially graph-structured datasets that not only contain the entities of a codebase but also the interlinked knowledge about them, including the semantic models of the programming language and the overall project structure.4 These graphs are often organized into layers of abstraction, ranging from high-level project dependencies down to the intricate details of individual methods.4 This layered approach allows for different levels of analysis and understanding of the codebase. Representing code in this manner moves beyond the limitations of a flat file structure by explicitly capturing the inherent interconnectedness of software components, which is crucial for more sophisticated analysis.4
This graphical representation of code offers several benefits for various software engineering tasks.4 One significant advantage is the ability to visualize dependencies between different parts of the code, making it easier to understand how various functions, classes, and modules rely on each other.6 This visualization simplifies debugging by allowing developers to trace the flow of data and identify potential sources of errors more effectively.5 For example, if an issue arises in a particular function, a code graph can quickly reveal which other functions it calls and which variables it uses, narrowing down the scope of the investigation.6 Furthermore, code graphs facilitate impact analysis by allowing developers to quickly assess the potential consequences of making changes to one part of the code on other parts.5 By examining the relationships in the graph, developers can identify which functions or classes depend on the code they intend to modify, enabling them to make more informed decisions and anticipate potential issues.6 Beyond these benefits, using graph databases to represent code also enables the analysis of source code and architecture quality, the calculation of various architectural metrics, and the identification of potential areas for improvement, such as code smells and technical debt.4 This structured approach empowers software engineers to make better decisions regarding refactoring and code optimization, ultimately leading to more maintainable and scalable software systems.7
3. LLMs and Code Knowledge Graphs: A Synergistic Approach
LLMs can significantly enhance their understanding and reasoning about code by leveraging the structured information contained within code knowledge graphs.5 Unlike processing raw text, which can be ambiguous and lack explicit relational information, LLMs can utilize the clearly defined nodes and edges in a knowledge graph to grasp the context of code elements more effectively.5 The structured nature of these graphs can help overcome some inherent limitations of LLMs when dealing with complex and interconnected data by providing a navigable and precise representation of the relationships within a codebase. This allows the LLM to understand not just the syntax of individual code snippets but also how they fit into the larger structure and depend on other components.
To access and utilize the information within a code knowledge graph, LLMs can work in conjunction with graph query languages such as Cypher.4 These query languages enable the precise retrieval of specific subgraphs that are relevant to a particular query or task.4 For example, if an LLM needs to understand the context of a specific function, a Cypher query can be used to retrieve not only the function itself but also all the functions that call it, the variables it uses, and the classes it belongs to [User Query]. This provides the LLM with a much richer and more contextual understanding than simply providing the raw text of the function. Furthermore, LLMs themselves can be employed to generate these Cypher statements from natural language queries, making the process of interacting with and extracting information from code knowledge graphs more accessible to developers who may not be experts in graph query languages.9 This natural language interface powered by LLMs acts as a translator, converting questions about the codebase into precise graph queries that can then be executed to retrieve the desired information.9
A powerful paradigm that combines the strengths of graph databases and LLMs for code analysis is Graph Retrieval-Augmented Generation (GraphRAG).8 GraphRAG enhances the responses of LLMs by retrieving relevant information from a knowledge graph and incorporating it into the generated output.18 This approach often involves using graph traversals and semantic search techniques to identify and surface the most relevant portions of a complex and interconnected knowledge graph to the LLM.14 By grounding the LLM's responses in the verified and structured data of a knowledge graph, GraphRAG can significantly improve the accuracy and relevance of the generated content, particularly in domains requiring high precision.8 For instance, when applied to code, GraphRAG can help an LLM generate more accurate and contextually appropriate edits or answers by providing it with a focused subgraph of the codebase that includes the relevant code elements and their relationships.8 This method can be particularly valuable for handling domain-specific knowledge and proprietary information often found in codebases.11 Some implementations even explore combining graph databases (for representing relationships) with vector databases (for capturing semantic similarities) within RAG systems to achieve optimal performance in complex generative AI applications.15 Tools like the Neo4j LLM Knowledge Graph Builder further streamline this process by using LLMs to automatically extract information from unstructured text and populate a graph database, which can then be readily used for GraphRAG applications.17 Overall, GraphRAG presents a promising avenue for enhancing the quality of LLM-generated code-related outputs by providing a more accurate and contextually rich understanding of the underlying codebase.
4. Evaluating the Performance: Empirical Evidence and Benchmarks
Several research studies have begun to evaluate the performance of LLMs when provided with code context derived from graph databases, often comparing this approach to more traditional methods like using plain text. While the field is still evolving, initial findings suggest that leveraging knowledge graphs can lead to notable improvements in various code-related tasks.2 For example, the CodexGraph framework, although the specific performance evaluation details from the cited source are inaccessible, aims to bridge the gap between LLMs and code repositories through code graph database interfaces, demonstrating competitive performance in software engineering tasks.1 Similarly, CodeGraphGPT, a system that utilizes a code knowledge graph to enhance fuzz driver generation, reported an average increase of 8.73% in code coverage compared to state-of-the-art methods.23 This improvement highlights the potential of knowledge graphs to guide LLMs in generating more effective testing code. In another study focusing on question answering over a database, researchers found that using a knowledge graph representation of an SQL database with GPT-4 achieved an accuracy of 54%, significantly higher than the 16% accuracy obtained when querying the raw SQL database directly.24 While this example is not directly about codebases, it illustrates the general principle that providing structured knowledge can substantially improve the performance of LLMs in understanding and answering questions about complex data. Furthermore, in the biomedical domain, GraphRAG has been shown to achieve a 2x increase in question answering accuracy compared to standard baselines.11 Although this result is in a different domain, it suggests the potential for similar gains when applying GraphRAG to code analysis.
The evaluation of these approaches involves various metrics depending on the specific task. For instance, CodexGraph's performance was assessed using metrics like Exact Match (EM) and Edit Similarity (ES), which measure the accuracy and similarity of the generated code.2 CodeGraphGPT, on the other hand, used code coverage as a primary metric, along with the reduction in manual workload for crash analysis and the number of real-world bugs identified.23 The study on question answering over an SQL database used the straightforward metric of accuracy in answering natural language questions.24 The consistency of these studies in reporting quantifiable benefits, whether in terms of code coverage, accuracy, or bug detection, indicates the promise of using graph databases to enhance LLM capabilities for code-related tasks.
Table 1: Performance Benchmarks of LLMs with Code Knowledge Graphs

| Study          | Task                                    | LLM Used | Graph Database    | Key Metrics                        | Improvement/Performance              | Snippet(s) |
|----------------|-----------------------------------------|----------|-------------------|------------------------------------|--------------------------------------|------------|
| CodexGraph     | Repository-level code tasks            | GPT-4o   | (Not specified)   | Exact Match (EM), Edit Similarity (ES) | Superior to existing methods          |            |
| CodeGraphGPT   | Fuzz Driver Generation                | (LLM)    | (Knowledge Graph) | Code Coverage                       | 8.73% average increase                |            |
|                | Question Answering over SQL Database   | GPT-4    | (Knowledge Graph) | Accuracy                            | 54% vs. 16% (over SQL)                |            |
|                | Question Answering (Biomedical Domain) | Llama-3  | Neo4j             | Hits@1, Hits@5, Recall@20, MRR      | 2x accuracy vs. baselines             |            |

5. Navigating the Challenges: Implementation and Scalability
While the potential benefits of using code knowledge graphs with LLMs are significant, there are practical challenges involved in their implementation and maintenance, especially for large and complex codebases.6 One of the primary hurdles is the sheer volume of code in large systems, which can make it difficult for even advanced RAG models to retrieve the most relevant snippets efficiently.6 Building a comprehensive and accurate knowledge graph from such a codebase requires robust processes for parsing the code, extracting relevant entities and relationships, and integrating this information into the graph structure.4 This process can be computationally intensive and may require specialized tools and expertise.
Another significant challenge lies in designing an effective schema for the code knowledge graph.25 The schema defines the types of nodes and edges in the graph and the properties associated with them. Determining the appropriate level of granularity for these elements is crucial for both the performance of the graph database and the effectiveness of the context provided to the LLM [User Query]. A poorly designed schema might not capture all the necessary information or could lead to a graph that is too complex to query efficiently. Furthermore, maintaining the accuracy and consistency of the code knowledge graph as the codebase evolves is an ongoing task.25 Any changes to the code need to be reflected in the graph, which requires automated processes for updating the graph structure. For very large codebases, the scalability of the graph database itself becomes a critical consideration.4 While distributed graph databases offer a solution for handling massive amounts of data, their implementation and management introduce additional complexities. Organizational issues, the costs associated with new technologies, and the need for skilled practitioners to manage the data pipeline also present considerable challenges in adopting this approach.29 The heterogeneity of data sources and the need for community-driven decisions on the scope and granularity of the knowledge graph, as seen in the context of scholarly knowledge graphs, can also find parallels in the diverse coding styles and project structures encountered in software development.28 Therefore, successful implementation requires careful planning, the selection of appropriate tools and technologies, and a deep understanding of both graph databases and software engineering principles.
6. Beyond Text: Comparing with Vector Embeddings and Other Techniques
When considering how to provide code context to LLMs, the graph-based approach offers a distinct alternative to methods like using vector embeddings.5 Vector databases excel at storing numerical representations of data, known as embeddings, which allow for efficient similarity searches.5 This is particularly useful for finding code snippets that are semantically similar to a given query, even if they don't share exact keywords.21 However, while vector embeddings capture semantic meaning, they don't inherently represent the explicit relationships between code elements in the same way that a knowledge graph does.5 Knowledge graphs, on the other hand, are specifically designed to capture these direct relationships, such as function calls, dependencies, and inheritance, through their network of nodes and edges.5 Research suggests that for tasks requiring a deep understanding of a codebase's architecture and dependencies, knowledge graphs offer advantages over vector databases.6 For instance, when analyzing code, a knowledge graph can return a detailed network of all methods that directly or indirectly call a specific function, along with their relationships, providing a more accurate and reliable context than a vector database that might rely on semantic similarity.6 Knowledge graphs are also considered superior for answering complex questions that involve multiple relationships and require precise and complete responses, as they traverse a network of connected information to retrieve the exact answer.31
Despite these advantages, both approaches have their strengths. Vector databases are highly effective for similarity searches in unstructured data and offer low-latency retrieval even with large datasets.5 Graph databases, while powerful for representing relationships and enabling complex queries, can face performance challenges as the graph becomes more interconnected and deeper.32 This has led to the exploration of hybrid solutions that combine the benefits of both technologies.5 By integrating vector and graph databases in a RAG system, it becomes possible to leverage the speed and semantic search capabilities of vector databases to retrieve relevant code snippets, while simultaneously using the structured relationships in a graph database to provide the LLM with the necessary architectural and dependency context.15 This combined approach could potentially offer the most comprehensive solution for enhancing LLM-based code analysis by addressing both semantic similarity and explicit relationships within the codebase.
7. The Role of Abstract Syntax Trees (ASTs) and Lisp-Inspired Structures
A crucial step in constructing a code knowledge graph is parsing the source code into a structured format that can then be used to identify code elements and their relationships. Abstract Syntax Trees (ASTs) play a vital role in this process.4 An AST is a hierarchical representation of the syntactic structure of code, abstracting away details like punctuation and formatting to focus on the essential elements of the code's structure.37 Tools like tree-sitter are highly efficient parser generators that can parse code into ASTs for a wide variety of programming languages.4 Once the code is represented as an AST, it can be traversed programmatically to identify different code elements such as functions, classes, variables, and their relationships, which can then be used to populate the nodes and edges of the graph database.36 For example, tree-sitter-graph is a specific library that defines a domain-specific language for constructing arbitrary graph structures from source code parsed by tree-sitter.33 Similarly, projects like ast-generator utilize ASTs (built using tools like javaparser) to create graph models of Java projects and insert them into graph databases like Neo4j.40 The combination of knowledge graphs and ASTs is seen as a powerful approach for building advanced coding chatbots that can understand both the syntactic and semantic aspects of code.41 Therefore, AST parsers are fundamental tools for automatically extracting the structural information from code that is necessary for building a comprehensive code knowledge graph.
In addition to leveraging ASTs, there is also potential in using Lisp-inspired tree structures, specifically S-expressions, in conjunction with graph databases for representing code.48 Lisp, a programming language known for its unique syntax, uses S-expressions (symbolic expressions) to represent both code and data as nested lists, which inherently form tree-like structures.48 This property, known as homoiconicity, means that the program's structure is directly reflected in its syntax, allowing code to be easily accessed and transformed as data.49 S-expressions can naturally represent the hierarchical organization of code, aligning well with the tree-like structure of ASTs and the concept of a graph database as a tree of named nodes.48 Representing parts of the code graph, or even the entire graph, as S-expressions could provide a format that is not only structurally rich but also readily processable by LLMs, given their extensive training on textual data that often exhibits hierarchical structures.48 The ability of Lisp to manipulate symbolic data structures like lists and trees makes it well-suited for symbolic computation and artificial intelligence applications.51 Furthermore, Lisp's powerful macro system allows for the creation of custom language constructs and transformations of code at a fundamental level.49 Thus, exploring the use of S-expressions in conjunction with graph databases could offer a powerful way to represent and reason about code for LLMs, potentially enhancing their ability to understand and manipulate software.
8. Applications and Future Directions
The utility of code knowledge graphs extends beyond just enhancing the capabilities of LLMs. They have a wide range of applications across the software development lifecycle, including code search, refactoring, bug detection, and code visualization.4 For instance, code graphs can be used to analyze the quality of software architecture, calculate important metrics, and identify potential issues like code smells and technical debt.7 They can also facilitate program search by allowing developers to navigate the codebase based on relationships between code elements rather than just keywords.53 The structured representation of code in a graph makes it easier to understand dependencies between different modules, functions, and classes, which is crucial for impact analysis when refactoring code.5 Furthermore, code knowledge graphs can aid in bug detection by visualizing execution paths and pinpointing the source of errors or performance bottlenecks.5 Tools are being developed to build code knowledge graphs for various purposes, such as program analysis, code understanding, and automation.53 In other domains, knowledge graphs have shown their ability to provide better context and consistency for AI systems, leading to more accurate reasoning and domain expertise, principles that can be readily applied to code analysis as well.54 The ability to visualize codebases as knowledge graphs allows developers to analyze dependencies, detect bottlenecks, and optimize their projects more effectively.22 By correlating various software development artifacts like user stories, test cases, code files, and defects, knowledge graphs can provide an end-to-end view of the software development lifecycle.56 The successful application of knowledge graphs in other complex domains, such as automotive engineering, for querying relationships and understanding the impact of changes, highlights their potential value for managing the complexity of software codebases.55
Given the promising results and the ongoing advancements in both LLMs and graph database technologies, the integration of these two fields for code analysis is a rapidly evolving area with many potential future research directions.1 Future work could explore more advanced graph architectures, such as graph transformers, to better capture the complex relationships in code.11 Improving the robustness of these systems to handle incomplete or noisy code graphs is another important area for research.11 As LLMs continue to evolve and become more powerful, further investigation into how they can be best leveraged to interact with and reason over code knowledge graphs is warranted.2 Exploring the scalability of these approaches to handle even larger and more complex codebases will also be crucial for their widespread adoption.11 The development of more sophisticated methods for automatically constructing and maintaining code knowledge graphs, as well as for querying and interpreting the information within them, will be essential for unlocking the full potential of this synergistic approach.1
9. Conclusion
The analysis of current research and available resources strongly suggests that integrating graph databases and knowledge graphs with Large Language Models offers a promising pathway to significantly enhance the capabilities of LLMs for code analysis and manipulation. By representing codebases as interconnected networks of entities and relationships, this approach provides a richer and more structured context for LLMs compared to traditional methods. This structured representation facilitates improved code understanding, more accurate reasoning, and the potential for more effective code generation and editing. Empirical evidence from studies in code generation, question answering over databases, and related domains indicates that leveraging knowledge graphs can lead to measurable performance improvements. While challenges remain in the practical implementation and scalability of building and maintaining code knowledge graphs, ongoing research and the development of specialized tools are actively addressing these issues. The comparison with alternative techniques like vector embeddings highlights the unique strengths of graph databases in capturing explicit relationships within code, suggesting that a hybrid approach combining both methods may offer the most comprehensive solution. Furthermore, the role of AST parsers in constructing these graphs and the potential of using Lisp-inspired S-expressions for code representation offer exciting avenues for future exploration. The broad range of applications for code knowledge graphs, extending beyond LLMs to areas like code search, refactoring, and bug detection, underscores the transformative potential of this technology for the entire software development lifecycle. As both LLMs and graph database technologies continue to advance, the synergy between them promises to unlock new levels of sophistication in how we understand, analyze, and interact with code.
Works cited
\framework: Bridging Large Language Models and Code Repositories via Code Graph Databases - arXiv, accessed April 6, 2025, https://arxiv.org/html/2408.03910v2
CodexGraph: Bridging Large Language Models and Code Repositories via Code Graph Databases - Powerdrill, accessed April 6, 2025, https://powerdrill.ai/discover/discover-CodexGraph-Bridging-Large-clzn708ww1l0s019w8cfr3foz
These are the best large language models for coding - DEV Community, accessed April 6, 2025, https://dev.to/hackmamba/these-are-the-best-large-language-models-for-coding-1co2
Codebase Knowledge Graph: Code Analysis with Graphs - Neo4j, accessed April 6, 2025, https://neo4j.com/blog/developer/codebase-knowledge-graph/
Code Graph: From Visualization to Integration - FalkorDB, accessed April 6, 2025, https://www.falkordb.com/blog/code-graph/
Enhancing Code Analysis With Code Graphs - DZone, accessed April 6, 2025, https://dzone.com/articles/enhancing-code-analysis-with-code-graphs
Integrated Source Code and Architectural Quality Analysis Using Neo4j Graph Database - DiVA portal, accessed April 6, 2025, https://www.diva-portal.org/smash/get/diva2:1851736/FULLTEXT01.pdf
GraphRAG — Knowledge Graph & LLM. As software engineers, we are… | by Mor Dvash | Israeli Tech Radar | Medium, accessed April 6, 2025, https://medium.com/israeli-tech-radar/graphrag-knowledge-graph-llm-660c3b23ef4a
Enhancing Interaction between Language Models and Graph Databases via a Semantic Layer | by Tomaz Bratanic - Medium, accessed April 6, 2025, https://medium.com/data-science/enhancing-interaction-between-language-models-and-graph-databases-via-a-semantic-layer-0a78ad3eba49
AI and Graph Databases: Enhancing Data Retrieval - Analytics Vidhya, accessed April 6, 2025, https://www.analyticsvidhya.com/blog/2024/02/ai-and-graph-databases-enhancing-data-retrieval/
Boosting Q&A Accuracy with GraphRAG Using PyG and Graph ..., accessed April 6, 2025, https://developer.nvidia.com/blog/boosting-qa-accuracy-with-graphrag-using-pyg-and-graph-databases/
Insights, Techniques, and Evaluation for LLM-Driven Knowledge Graphs | NVIDIA Technical Blog, accessed April 6, 2025, https://developer.nvidia.com/blog/insights-techniques-and-evaluation-for-llm-driven-knowledge-graphs/
GraphRAG: Unlocking LLM discovery on narrative private data - Microsoft Research, accessed April 6, 2025, https://www.microsoft.com/en-us/research/blog/graphrag-unlocking-llm-discovery-on-narrative-private-data/
Is Traditional SaaS Behind Us? The Graph + GenAI Revolution - Neo4j, accessed April 6, 2025, https://neo4j.com/blog/genai/graph-ai-tier/
Boosting AI with Graph and Vector Databases in RAG System - TenUp Software Services, accessed April 6, 2025, https://www.tenupsoft.com/blog/boosting-ai-with-graph-and-vector-databases-in-rag-system.html
How GenAI Provides Deep Understanding With Knowledge Graphs - Neo4j, accessed April 6, 2025, https://neo4j.com/blog/genai/genai-knowledge-graph-deep-understanding/
Introduction to the Neo4j LLM Knowledge Graph Builder - Graph Database & Analytics, accessed April 6, 2025, https://neo4j.com/blog/developer/llm-knowledge-graph-builder/
LLM + Graph Database for Retrieval Augmented Generation (RAG) - YouTube, accessed April 6, 2025, https://www.youtube.com/watch?v=wUDZbqA4J2E
Knowledge Graphs & LLMs: Multi-Hop Question Answering - Neo4j, accessed April 6, 2025, https://neo4j.com/blog/developer/knowledge-graphs-llms-multi-hop-question-answering/
Graph RAG vs Vector RAG: A Comprehensive Tutorial with Code Examples, accessed April 6, 2025, https://ragaboutit.com/graph-rag-vs-vector-rag-a-comprehensive-tutorial-with-code-examples/
Graph Databases vs. Vector Databases: Supercharging Retrieval-Augmented Generation (RAG) | by Rajesh Rajamani | primepartnerstech | Feb, 2025 | Medium, accessed April 6, 2025, https://medium.com/primepartnerstech/graph-databases-vs-vector-databases-supercharging-retrieval-augmented-generation-rag-f5048df347f6
How to Use Knowledge Graph Tools to Enhance AI Development - FalkorDB, accessed April 6, 2025, https://www.falkordb.com/blog/how-to-use-knowledge-graph-tools-for-ai/
A Code Knowledge Graph-Enhanced System for LLM-Based Fuzz Driver Generation - arXiv, accessed April 6, 2025, https://arxiv.org/html/2411.11532v1
A Benchmark to Understand the Role of Knowledge Graphs on Large Language Model's Accuracy for Question Answering on Enterpri - arXiv, accessed April 6, 2025, https://arxiv.org/pdf/2311.07509
Knowledge Graph Extraction and Challenges - Graph Database ..., accessed April 6, 2025, https://neo4j.com/blog/developer/knowledge-graph-extraction-challenges/
Addressing common challenges with knowledge graphs - SciBite, accessed April 6, 2025, https://scibite.com/knowledge-hub/news/common-challenges-with-knowledge-graphs/
[D] - Challenges in querying data from a knowledge graph : r/MachineLearning - Reddit, accessed April 6, 2025, https://www.reddit.com/r/MachineLearning/comments/1ic5q7s/d_challenges_in_querying_data_from_a_knowledge/
Challenges in building scholarly knowledge graphs for research assessment in open science - MIT Press Direct, accessed April 6, 2025, https://direct.mit.edu/qss/article/5/4/991/123928/Challenges-in-building-scholarly-knowledge-graphs
Knowledge Graph Implementation: Costs & Obstacles - Cutter Consortium, accessed April 6, 2025, https://www.cutter.com/article/knowledge-graph-implementation-costs-obstacles
Vector Database Vs. Graph Database: 6 Key Differences - Airbyte, accessed April 6, 2025, https://airbyte.com/data-engineering-resources/vector-database-vs-graph-database
Knowledge Graph vs. Vector Database for Grounding Your LLM - Neo4j, accessed April 6, 2025, https://neo4j.com/blog/genai/knowledge-graph-vs-vectordb-for-retrieval-augmented-generation/
Vector Database vs Graph Database: Key Technical Differences - FalkorDB, accessed April 6, 2025, https://www.falkordb.com/blog/vector-database-vs-graph-database/
tree-sitter/tree-sitter-graph: Construct graphs from parsed source code - GitHub, accessed April 6, 2025, https://github.com/tree-sitter/tree-sitter-graph
IBM/tree-sitter-codeviews: Extract and combine multiple source code views using tree-sitter - GitHub, accessed April 6, 2025, https://github.com/IBM/tree-sitter-codeviews
tree-sitter-stack-graphs-python 0.3.0 - Docs.rs, accessed April 6, 2025, https://docs.rs/crate/tree-sitter-stack-graphs-python/latest
Building Call Graphs for Code Exploration Using Tree-Sitter - DZone, accessed April 6, 2025, https://dzone.com/articles/call-graphs-code-exploration-tree-sitter
A Beginner's Guide to Tree-sitter - DEV Community, accessed April 6, 2025, https://dev.to/shreshthgoyal/understanding-code-structure-a-beginners-guide-to-tree-sitter-3bbc
Graphlr: indexing antlr3 generated Java AST through a Neo4j graph - codecentric AG, accessed April 6, 2025, https://www.codecentric.de/knowledge-hub/blog/graphlr-indexing-antlr3-generated-java-ast-through-a-neo4j-graph
Exploring Abstract Syntax Trees with ArangoDB - YouTube, accessed April 6, 2025, https://www.youtube.com/watch?v=IJk8SCdw-_s
AST-generator project creates an Abstract Syntax Tree (AST) for each file of a Java project, translates them to graph models and inserts them to Neo4J (Graph Distributed DB) instance - GitHub, accessed April 6, 2025, https://github.com/ElasticT3am/ast-generator
Advanced Coding Assistant: Knowledge Graphs and ASTs | by Cyril Sadovsky | Medium, accessed April 6, 2025, https://medium.com/@cyrilsadovsky/advanced-coding-chatbot-knowledge-graphs-and-asts-0c18c90373be
Data model for transforming source into AST and back? - Stack Overflow, accessed April 6, 2025, https://stackoverflow.com/questions/71166173/data-model-for-transforming-source-into-ast-and-back
AST: Hierarchical Code Structure for Analysis | Lenovo US, accessed April 6, 2025, https://www.lenovo.com/us/en/glossary/ast/
Abstract syntax tree - Wikipedia, accessed April 6, 2025, https://en.wikipedia.org/wiki/Abstract_syntax_tree
GAST: A Generic AST Representation for Language-Independent Source Code Analysis, accessed April 6, 2025, https://www.redalyc.org/journal/5722/572276219003/html/
Do most languages construct an AST? : r/ProgrammingLanguages - Reddit, accessed April 6, 2025, https://www.reddit.com/r/ProgrammingLanguages/comments/1awhsz4/do_most_languages_construct_an_ast/
cedricrupb/code_ast: Fast and robust AST parsing of any language - GitHub, accessed April 6, 2025, https://github.com/cedricrupb/code_ast
S-expression - Wikipedia, accessed April 6, 2025, https://en.wikipedia.org/wiki/S-expression
(learn '(LISP)) - Codementor, accessed April 6, 2025, https://www.codementor.io/@skilbjo/learn-lisp-hba8gwngh
lisp - What is an S-Expression - Stack Overflow, accessed April 6, 2025, https://stackoverflow.com/questions/74172158/what-is-an-s-expression
From S-Expressions to AI: A Deep Dive into Lisp Programming Language, accessed April 6, 2025, https://softwaredominos.com/home/software-engineering-and-computer-science/from-s-expressions-to-ai-a-deep-dive-into-lisp-programming-language/
A Tour of the Lisps | Hacker News, accessed April 6, 2025, https://news.ycombinator.com/item?id=39182721
A Toolkit for Generating Code Knowledge Graphs for K-CAP 2021 - IBM Research, accessed April 6, 2025, https://research.ibm.com/publications/a-toolkit-for-generating-code-knowledge-graphs
How Ontologies and Knowledge Graphs Elevate LLMs Beyond Probability - Nitesh Khilwani, accessed April 6, 2025, https://aicrumbs.medium.com/how-ontologies-and-knowledge-graphs-elevate-llms-beyond-probability-15e7f8ff6cd0
Knowledge Graphs explained: How you turn data into valuable insights - Spread AI, accessed April 6, 2025, https://www.spread.ai/resources/stories/knowledge-graphs-explained-how-data-becomes-valuable-insights
Using Knowledge Graphs and Large Language Models to Accelerate Software Delivery | LTIMindtree Blog, accessed April 6, 2025, https://www.ltimindtree.com/blogs/using-knowledge-graphs-and-large-language-models-to-accelerate-software-delivery/
